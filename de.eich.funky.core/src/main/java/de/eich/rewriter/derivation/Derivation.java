/**
 * @author Julian Eichhoff
 *
 * Copyright 2014 Julian Eichhoff
 */
package de.eich.rewriter.derivation;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import org.javatuples.Pair;

import de.eich.rewriter.AbstractRewriteSystem;
import de.eich.rewriter.Rewriter;
import de.eich.rewriter.functionstructure.FunctionStructure;
import de.eich.utils.ComparableList;

public class Derivation {
	
	public Rewriter rewriter;
	public RuleSequence ruleSequence;

	public final List<DerivationGroupSet> derivationGroupSets = new ArrayList<DerivationGroupSet>();
	public int notApplicableAtAllRuleIndex = -1;
	
	public Derivation(RuleSequence ruleSequence, Rewriter rewriter){
		this.ruleSequence = ruleSequence;
		this.rewriter = rewriter;
	}
	
	public static int timeout = 60000; // 60 seconds
	
	public Set<Pair<FunctionStructure,FunctionStructure>> derive(int nextRuleIndex, Set<FunctionStructure> sources) {
		// all function structures generated by applying nextRuleIndex on current host graphs
		Set<Pair<FunctionStructure,FunctionStructure>> resultingFunctionStructures = new HashSet<Pair<FunctionStructure,FunctionStructure>>();

		// reference to current host graphs
		DerivationGroupSet currentDerivationGroupSet;
		
		// application of first rule is treated specially
		if(nextRuleIndex == 0) {
			
			currentDerivationGroupSet = addDerivationGroupSet();
			
			for(FunctionStructure source : sources){
				
				// try to find new group
				DerivationGroup newGroup = rewriter.derivationGroupCache.getDerivationGroup(source, this.ruleSequence, null, nextRuleIndex, this);
				
				if(newGroup != null){
					currentDerivationGroupSet.add(newGroup);
					
					resultingFunctionStructures.addAll(newGroup.addDirectDerivationsFromSource2());
				} else {
					// compute from scratch
					newGroup = new DerivationGroup(new DerivationGroupHost(source, ruleSequence, 0), this);
					currentDerivationGroupSet.add(newGroup);
					
					resultingFunctionStructures.addAll(newGroup.addDirectDerivationsFromSource());
				}
			}
			
			if(resultingFunctionStructures.isEmpty()) {
				notApplicableAtAllRuleIndex = nextRuleIndex;
			}
			
			setDerivationGroupIndices(currentDerivationGroupSet);
			
		} else {
			
			boolean noDirectDerivationsAvailable = true; // if true last rule was not applicable at all
			
			DerivationGroupSet nextDerivationGroupSet = new DerivationGroupSet(this);
			
			int currentRuleIndex = derivationGroupSets.size() -1;
			
			currentDerivationGroupSet = derivationGroupSets.get(currentRuleIndex);
			
			long start = System.currentTimeMillis();
			
			for(DerivationGroup derivationGroup : currentDerivationGroupSet){
				
				if(System.currentTimeMillis() - start > timeout){
					System.out.println("timeout");
					return null;
				}
				
				List<Integer> lowerRuleIndices = getLowerRuleIndices(derivationGroup, nextRuleIndex); 

				// get best re-instantiation for this group
				int size = 0;
				Map<FunctionStructure, Pair<DerivationGroup, List<DirectDerivation>>> nextGroups = null;
				if(derivationGroup.hasDirectDerivationsForIndices(lowerRuleIndices)) {
					noDirectDerivationsAvailable = false; 
					
					// join lower rule indices and search for existing groups
					nextGroups = derivationGroup.reinstantiateNextGroups(nextRuleIndex, lowerRuleIndices); 
					for(Pair<DerivationGroup, List<DirectDerivation>> nextGroup : nextGroups.values()){
						if(nextGroup.getValue0() == null){
							size = -1; // could not find existing group for every join
							break;
						} else {
							size = Math.max(size, nextGroup.getValue0().independentIndices.size()); // contains nextRuleIndex and following indices
						}
					}
				}
				
				int size2 = 0; // contains nextRuleIndex and following indices
				for(int ruleIndex : derivationGroup.independentIndices)
					if(ruleIndex >= nextRuleIndex) size2++; 

				// its better to use current derivation group where possible
				if (derivationGroup.independentIndices.contains(nextRuleIndex) 
						&& (size2 >= size || getNotApplicableRuleIndex(currentDerivationGroupSet) != -1)) { // if n/a nothing more must be derived
					
					if(derivationGroup.hasDirectDerivationsForIndex(currentRuleIndex)){
						resultingFunctionStructures.addAll(derivationGroup.makeChildren2(currentRuleIndex, nextRuleIndex, nextGroups));
						nextDerivationGroupSet.addAll(derivationGroup.children);
					}
					
				} else if(nextGroups != null){
					resultingFunctionStructures.addAll(derivationGroup.makeChildren(nextRuleIndex, nextGroups));
					nextDerivationGroupSet.addAll(derivationGroup.children);
				}
					
			}
				
			if(resultingFunctionStructures.isEmpty() && (notApplicableAtAllRuleIndex == -1 || nextRuleIndex < notApplicableAtAllRuleIndex)) {
				notApplicableAtAllRuleIndex = nextRuleIndex;
			} 
			
			if(!noDirectDerivationsAvailable){
				derivationGroupSets.add(nextDerivationGroupSet);
				setDerivationGroupIndices(nextDerivationGroupSet);
			}
		}
			
		return resultingFunctionStructures;
	}
	
	
	
	
	private boolean simpleDepdendent(int candidateRuleIndex, int derivationGroupSetIndex){
		int candidateRuleID = ruleSequence.get(candidateRuleIndex).id;
		
		for(int ruleIndexMember : derivationGroupSets.get(derivationGroupSetIndex).independentIndices){
			int memberRuleID = ruleSequence.get(ruleIndexMember).id;
			if(rewriter.derivationGroupCache.isDependentIDPair(memberRuleID, candidateRuleID) || memberRuleID == candidateRuleID){
				return true;
			}
		}
		
		return false;
	}
	
	public void applyShifts(int ruleIndexCandidate){
		// candidate will be shifted into group at derivationGroupSetIndex
		for(int derivationGroupSetIndex = ruleIndexCandidate -1; derivationGroupSetIndex >= 0; derivationGroupSetIndex--){
			
			boolean addToSet = true;
			outer: for(DerivationGroup derivationGroup : derivationGroupSets.get(derivationGroupSetIndex)){
				if(derivationGroup.candidateManager.prepareCandidate(ruleIndexCandidate)){
					// conduct independence testing
					boolean candidateIsDependent;
					boolean testedChecked = false;
					
					if(simpleDepdendent(ruleIndexCandidate, derivationGroupSetIndex)){
						candidateIsDependent = true;
					} else if(rewriter.derivationGroupCache.wasNotApplicableBefore(this, ruleIndexCandidate, derivationGroupSetIndex)){
						// applying candidate to this derivation group set will result in empty direct derivations
						// if the candidate wasn't applicable in the first place this is ok since nothing changed -> independent
						// otherwise direct derivations were lost and candidate must be dependent
						candidateIsDependent = this.notApplicableAtAllRuleIndex != ruleIndexCandidate;
					} else {
						List<Integer> testedIndependent = new ComparableList<Integer>();
						List<Integer> otherMembersRuleIndices = new ComparableList<Integer>(derivationGroup.independentIndices);
					
						candidateIsDependent = false;
						for(int i = 0; i < otherMembersRuleIndices.size(); i++) {
							int ruleIndexMember = otherMembersRuleIndices.remove(i);
							
							Boolean simpleTest = derivationGroup.candidateManager.simpleTestCandidate(ruleIndexMember);
							if(simpleTest != null){
								candidateIsDependent = simpleTest;
							} else {
								// the shift should yield in the coverage of other rule sequences, if most of these rule sequences have been derived yet it is useless to perform shifting
								if(!testedChecked && rewriter.derivationGroupCache.tested(this, ruleIndexCandidate, derivationGroupSetIndex)){
									addToSet = false;
									break outer;
								} else {
									testedChecked = true;
								}
								
								int cost = AbstractRewriteSystem.directDerivationCounter;
								if(derivationGroup.candidateManager.testCandidate(ruleIndexMember, otherMembersRuleIndices, testedIndependent)){
									rewriter.derivationGroupCache.addReversedDerivationGroups(derivationGroup, this);
									rewriter.derivationGroupCache.addDependentIDPair(ruleSequence.get(ruleIndexMember).id, ruleSequence.get(ruleIndexCandidate).id);
									candidateIsDependent = true;
								} else {
									testedIndependent.add(ruleIndexMember);
								}
								cost = AbstractRewriteSystem.directDerivationCounter - cost;
								AbstractRewriteSystem.addCost(ruleSequence.get(ruleIndexMember).id, ruleSequence.get(ruleIndexCandidate).id, cost);
							}
							
							otherMembersRuleIndices.add(i, ruleIndexMember);
							if(candidateIsDependent) break;
						}
					}
					
					if(candidateIsDependent){
						// candidate is not independent of all rules within preceding derivation group set
						// testing further derivation group sets is not necessary
						derivationGroup.candidateManager.removeFailedAndUntestedMembersOfChildren(derivationGroupSetIndex); // each group set index should refer to the same rule index 
						
						addToSet = false;
					} else {
						derivationGroup.candidateManager.confirmCandidate();
					}
				} else {
					addToSet = false;
				}
			}
			
			if(addToSet){
				derivationGroupSets.get(derivationGroupSetIndex).independentIndices.add(ruleIndexCandidate);
			}
			
			// if it worked out for every one add it to set
		}
	}
	
	
	
	
	private DerivationGroupSet addDerivationGroupSet(){
		DerivationGroupSet derivationGroupSet = new DerivationGroupSet(this);
		derivationGroupSets.add(derivationGroupSet);
		return derivationGroupSet;
	}
	
	private void setDerivationGroupIndices(DerivationGroupSet derivationGroupSet){
		derivationGroupSet.independentIndices.clear();
		Set<Integer> commonRuleIndices = null;
		for(DerivationGroup derivationGroup : derivationGroupSet){
			if(commonRuleIndices == null){
				commonRuleIndices = new TreeSet<Integer>(derivationGroup.independentIndices);
			} else {
				for(Iterator<Integer> iterator = commonRuleIndices.iterator(); iterator.hasNext();){
					if(!derivationGroup.independentIndices.contains(iterator.next()))
						iterator.remove();
				}
			}
		}
		derivationGroupSet.independentIndices.addAll(commonRuleIndices);
	}
	
	private List<Integer> getLowerRuleIndices(DerivationGroup derivationGroup, int ruleIndexCandidate){
		List<Integer> ruleIndices = new ComparableList<Integer>();
		for(int ruleIndex : derivationGroup.independentIndices){
			if(ruleIndex < ruleIndexCandidate){
				ruleIndices.add(ruleIndex);
			}
		}
		Collections.sort(ruleIndices);
		return ruleIndices;
	}
	
	private int getNotApplicableRuleIndex(DerivationGroupSet derivationGroupSet){
		for(int ruleIndex : derivationGroupSet.independentIndices){
			boolean empty = true;
			for(DerivationGroup derivationGroup : derivationGroupSet){
				if(!derivationGroup.memberDirectDerivations.get(ruleIndex).isEmpty()){
					empty = false;
					break;
				}
			}
			if(empty == true)
				return ruleIndex;
		}
		return -1;
	}
	
	public String toString(){
		return derivationGroupSets.toString() + " NA: " + notApplicableAtAllRuleIndex;
	}
}
